
使用言語:Python

ターミナル、またはコマンドプロンプトより、「python ファイル名.py」で実行可能です

お題１（q_1.py）フィボナッチ数列
実行すれば問題1_1と問題1_2の答えが返ってきます。
フィボナッチ数列は項数が多くなればなるほど再帰回数が増えてしまうため、再帰は使わず
0項からn項までの数列を出力する際には配列とfor文で、
単項を出力する際には一般項を使用して出力するようにしました。

お題２（q_2.py）IPアドレス判定
実行するとaddress.txtに記されているアドレスを読み込み、
正規表現が合っているかどうか判定しています。
しかし、ライブラリにあったre.matchは文章の先頭部分の正規表現が合っているかどうかしか判定しないようなので
こちらの判定では  0〜255までの　３桁.３桁.３桁.３桁 　という判定にしましたが、
「192.168.0.1010」のように、IPの最後「1010」が４ケタでも
上３ケタが0〜255以内の数字(この場合なら1010上３桁が101なのでOK)であればTrueを返す現象がどうしても直せず、
問題で与えられた文字列にそれぞれIPの区切りを示す「,」が入っているのを利用し、
条件に加え、最後が３ケタ＋「,」がついていないとTrueを返さない　というプログラムになりました。　
よって、一度読み込んだ文字列に「,」がなければ一番後ろに挿入し、
表示するときは「,」を外すという遠回りな処理になりました。
もし、「,」が文字列の途中に入っていて後ろに挿入されなくてもそもそも「,」が途中にある時点で
正規表現を満たしていないことになるので問題はないという判断です。

お題３（q_3.py)フラクタル図形
実行したあと実行回数K、正方形の辺の長さN、模様となる文字列s_1〜s_nをそれぞれ入力してください
こちらは難しかったので一度Javaで組んでからPythonに落とし込みました。
判定ケース1を例として考え方を述べます。
処理1.再帰処理を行い、下限に近付いたら、入力された以下の文字列s_1〜s_nを２次元配列で返します。
#.
##

処理2.次に、入力された文字列を順番に判定していき、#ならば上記の文字列を並べる、.ならば.だけで構成された文字列を並べる
判定ケース1だと正方形を第一象限、第二象限...のように分けられるので、
第一象限が「#」なら上のパターンを第一象限に敷き詰める、「.」なら.を敷き詰めるという感じのイメージです。
#.|..
##|..
------
#.|#.
##|##

処理3.できた上記のパターンを返し、今度はそのパターンを使用して、処理2を行う。
#...|....
##..|....
#.#.|....
####|....
―――――
#...|#...
##..|##..
#.#.|#.#.
####|####

これを繰り返すことでフラクタル図形を作成する。
パターンの保持方法は全て２次元配列で行っています。
最後に配列の中身を１つ１つ参照して書き出しています。
パターンを敷き詰める方法は配列のn〜mまでの要素を敷き詰めるパターンで入れ替えるという方法で行っています。
入力条件に合っていないものをはじくエラー処理は入れていません。